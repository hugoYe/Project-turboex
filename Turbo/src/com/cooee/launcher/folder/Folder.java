package com.cooee.launcher.folder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import android.animation.Animator;
import android.animation.Animator.AnimatorListener;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.android.launcher.framework.ApplicationInfo;
import com.android.launcher.framework.FastBitmapDrawable;
import com.android.launcher.framework.FolderInfo;
import com.android.launcher.framework.FolderInfo.FolderListener;
import com.android.launcher.framework.IconCache;
import com.android.launcher.framework.ItemInfo;
import com.android.launcher.framework.LauncherModel;
import com.android.launcher.framework.LauncherSettings;
import com.android.launcher.framework.ShortcutInfo;
import com.cooee.launcher.Alarm;
import com.cooee.launcher.Alarm.OnAlarmListener;
import com.cooee.launcher.CellLayout;
import com.cooee.launcher.Cling;
import com.cooee.launcher.Launcher;
import com.cooee.launcher.LauncherAnimUtils;
import com.cooee.launcher.LauncherApplication;
import com.cooee.launcher.ShortcutAndWidgetContainer;
import com.cooee.launcher.focushelper.FolderKeyEventListener;
import com.cooee.launcher.framework.drag.DragController;
import com.cooee.launcher.framework.drag.DragLayer;
import com.cooee.launcher.framework.drag.DragSource;
import com.cooee.launcher.framework.drag.DragView;
import com.cooee.launcher.framework.drag.DropTarget;
import com.cooee.uiengine.guiwidgets.PageIndicator;
import com.cooeeui.brand.turbolauncher.R;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource,
		View.OnClickListener, View.OnLongClickListener, DropTarget,
		FolderListener, TextView.OnEditorActionListener,
		View.OnFocusChangeListener {
	private static final String TAG = "Launcher.Folder";

	protected DragController mDragController;
	protected Launcher mLauncher;
	public FolderInfo mInfo;

	static final int STATE_NONE = -1;
	static final int STATE_SMALL = 0;
	static final int STATE_ANIMATING = 1;
	static final int STATE_OPEN = 2;

	private int mExpandDuration;
	protected CellLayout mContent;
	private final LayoutInflater mInflater;
	// leexingwang add leexingwang@2014/12/15 ADD START
	private LinearLayout mfolder_upper_half_part;
	private LinearLayout mfolder_add_button;
	private LinearLayout mfolder_lower_half_part;
	private ImageButton mFolderAddButton;
	private ArrayList<CellLayout> cellLayouts = new ArrayList<CellLayout>();
	private PageIndicator mfolderUpperHalfPartPageIndicator;
	private View mOpenBg;
	// leexingwang add leexingwang@2014/12/15 ADD END
	private final IconCache mIconCache;
	private int mState = STATE_NONE;
	private static final int REORDER_ANIMATION_DURATION = 230;
	private static final int ON_EXIT_CLOSE_DELAY = 800;
	private boolean mRearrangeOnClose = false;
	private FolderIcon mFolderIcon;
	private int mMaxCountX;
	private int mMaxCountY;
	private int mMaxNumItems;
	private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
	private Drawable mIconDrawable;
	boolean mItemsInvalidated = false;
	private ShortcutInfo mCurrentDragInfo;
	private View mCurrentDragView;
	boolean mSuppressOnAdd = false;
	private int[] mTargetCell = new int[2];
	private int[] mPreviousTargetCell = new int[2];
	private int[] mEmptyCell = new int[2];
	private Alarm mReorderAlarm = new Alarm();
	private Alarm mOnExitAlarm = new Alarm();
	private int mFolderNameHeight;
	private Rect mTempRect = new Rect();
	private boolean mDragInProgress = false;
	private boolean mDeleteFolderOnDropCompleted = false;
	private boolean mSuppressFolderDeletion = false;
	private boolean mItemAddedBackToSelfViaIcon = false;
	// leexingwang add leexingwang@2014/12/15 ADD START
	private boolean mAddButIsOrNotClick = true;
	private boolean mFolderBgIsOrNotShow = true;
	// leexingwang add leexingwang@2014/12/15 ADD END
	// leexingwang leexingwang@2015/01/06 ADD START
	private FrameLayout frameLayout;
	private DragLayer mDragLayer;
	private ArrayList<Point> pointsLocationOnWindows;
	private ArrayList<Point> points;
	// leexingwang leexingwang@2015/01/06 ADD END
	public FolderEditText mFolderName;
	private float mFolderIconPivotX;
	private float mFolderIconPivotY;

	private boolean mIsEditingName = false;
	private InputMethodManager mInputMethodManager;

	private static String sDefaultFolderName;
	private static String sHintText;
	private ObjectAnimator mOpenCloseAnimator;

	private boolean mDestroyed;

	/**
	 * Used to inflate the Workspace from XML.
	 * 
	 * @param context
	 *            The application's context.
	 * @param attrs
	 *            The attribtues set containing the Workspace's customization
	 *            values.
	 */
	public Folder(Context context, AttributeSet attrs) {
		super(context, attrs);
		setAlwaysDrawnWithCacheEnabled(false);
		mInflater = LayoutInflater.from(context);
		mIconCache = ((LauncherApplication) context.getApplicationContext())
				.getIconCache();

		Resources res = getResources();
		mMaxCountX = res.getInteger(R.integer.folder_max_count_x);
		mMaxCountY = res.getInteger(R.integer.folder_max_count_y);
		mMaxNumItems = res.getInteger(R.integer.folder_max_num_items);
		if (mMaxCountX < 0 || mMaxCountY < 0 || mMaxNumItems < 0) {
			mMaxCountX = LauncherModel.getCellCountX();
			mMaxCountY = LauncherModel.getCellCountY();
			mMaxNumItems = mMaxCountX * mMaxCountY;
		}

		mInputMethodManager = (InputMethodManager) getContext()
				.getSystemService(Context.INPUT_METHOD_SERVICE);

		mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

		if (sDefaultFolderName == null) {
			sDefaultFolderName = res.getString(R.string.folder_name);
		}
		if (sHintText == null) {
			sHintText = res.getString(R.string.folder_hint_text);
		}
		mLauncher = (Launcher) context;
		// We need this view to be focusable in touch mode so that when text
		// editing of the folder
		// name is complete, we have something to focus on, thus hiding the
		// cursor and giving
		// reliable behvior when clicking the text field (since it will always
		// gain focus on click).
		setFocusableInTouchMode(true);
		// leexingwang leexingwang@2015/01/04 ADD START
		setChildrenDrawingOrderEnabled(true);
		// leexingwang leexingwang@2015/01/04 ADD END
	}

	// leexingwang leexingwang@2014/12/22 ADD START
	public View getmContent() {
		return mContent;
	}

	// leexingwang leexingwang@2014/12/22 ADD END
	protected void onFinishInflate() {
		super.onFinishInflate();
		mContent = (CellLayout) findViewById(R.id.folder_up_container);
		mContent.setGridSize(0, 0);
		mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
		// leexingwang 设置mcontent外面的蓝色框 leexingwang@2014/12/19 ADD START
		mContent.setBackgroundResource(R.drawable.folder_edge_hint);
		mContent.setBackgroundColor(Color.TRANSPARENT);
		// leexingwang 设置mcontent外面的蓝色框 leexingwang@2014/12/19 ADD END
		mFolderName = (FolderEditText) findViewById(R.id.folder_name);
		mFolderName.setFolder(this);
		mFolderName.setOnFocusChangeListener(this);
		// We find out how tall the text view wants to be (it is set to
		// wrap_content), so that
		// we can allocate the appropriate amount of space for it.
		int measureSpec = MeasureSpec.UNSPECIFIED;
		mFolderName.measure(measureSpec, measureSpec);
		mFolderNameHeight = mFolderName.getMeasuredHeight();
		// leexingwang 指示器view add leexingwang@2014/12/15 ADD START
		mfolderUpperHalfPartPageIndicator = (PageIndicator) findViewById(R.id.folder_upper_half_part_page_indicator);
		// DragLayer.LayoutParams lp = new DragLayer.LayoutParams(0, 0);
		// int m = (int) getResources().getDimension(
		// R.dimen.folder_upper_half_part_page_indicator_margintop);
		// Log.i("folder", "folder_upper_half_part_page_indicator_margintop:" +
		// m);
		// m = (int) getResources().getDimension(
		// R.dimen.folder_pagerview_margintop);
		// Log.i("folder", "folder_pagerview_margintop:" + m);
		// mPageIndicator.setTop((int) getResources().getDimension(
		// R.dimen.folder_upper_half_part_page_indicator_margintop));
		// mContent.setTop((int) getResources().getDimension(
		// R.dimen.folder_pagerview_margintop));
		// leexingwang add 指示器view leexingwang@2014/12/15 ADD END
		// We disable action mode for now since it messes up the view on phones
		mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
		mFolderName.setOnEditorActionListener(this);
		// leexingwang 设置隐藏文字的颜色为白色 leexingwang@2014/12/20 ADD START
		mFolderName.setHintTextColor(Color.WHITE);
		// leexingwang 设置隐藏文字的颜色为白色 leexingwang@2014/12/20 ADD END
		mFolderName.setSelectAllOnFocus(true);
		mFolderName.setInputType(mFolderName.getInputType()
				| InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
				| InputType.TYPE_TEXT_FLAG_CAP_WORDS);

		// leexingwang 得到addbutton的view并给其添加事件监听 leexingwang@2014/12/20 ADD
		// START
		mFolderAddButton = (ImageButton) findViewById(R.id.folder_add_button);
		mFolderAddButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				// if (mAddButIsOrNotClick) {
				// mFolderAddButton
				// .setBackgroundResource(R.drawable.folder_button_over);
				// mFolderAddButton.offsetTopAndBottom(10);
				// mFolderAddButton.offsetLeftAndRight(10);
				// mAddButIsOrNotClick = false;
				// } else {
				// mFolderAddButton
				// .setBackgroundResource(R.drawable.folder_button);
				// mAddButIsOrNotClick = true;
				// }
			}
		});
		// leexingwang 得到addbutton的view并给其添加事件监听 leexingwang@2014/12/20 ADD END
	}

	private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
		public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
			return false;
		}

		public boolean onCreateActionMode(ActionMode mode, Menu menu) {
			return false;
		}

		public void onDestroyActionMode(ActionMode mode) {
		}

		public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
			return false;
		}
	};

	public void onClick(View v) {
		Object tag = v.getTag();
		if (tag instanceof ShortcutInfo) {
			// refactor this code from Folder
			ShortcutInfo item = (ShortcutInfo) tag;
			int[] pos = new int[2];
			v.getLocationOnScreen(pos);
			item.intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0]
					+ v.getWidth(), pos[1] + v.getHeight()));

			// leexingwang 动画执行期间屏蔽点击事件 leexingwang@2014/12/29 ADD START
			if (!DragLayer.isOrNotOnClickDurtionOpenFolderAnimation) {
				mLauncher.startActivitySafely(v, item.intent, item);
			}
			// leexingwang 动画执行期间屏蔽点击事件 leexingwang@2014/12/29 ADD END

		}
	}

	public boolean onLongClick(View v) {
		// Return if global dragging is not enabled
		if (!mLauncher.isDraggingEnabled())
			return true;
		Object tag = v.getTag();
		if (tag instanceof ShortcutInfo) {
			ShortcutInfo item = (ShortcutInfo) tag;
			if (!v.isInTouchMode()) {
				return false;
			}

			mLauncher.dismissFolderCling(null);

			mLauncher.getWorkspace().onDragStartedWithItem(v);
			mLauncher.getWorkspace().beginDragShared(v, this);
			mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

			mCurrentDragInfo = item;
			mEmptyCell[0] = item.cellX;
			mEmptyCell[1] = item.cellY;
			mCurrentDragView = v;

			mContent.removeView(mCurrentDragView);
			mInfo.remove(mCurrentDragInfo);
			mDragInProgress = true;

			mItemAddedBackToSelfViaIcon = false;
		}
		return true;
	}

	public boolean isEditingName() {
		return mIsEditingName;
	}

	public void startEditingFolderName() {
		mFolderName.setHint("");
		// leexingwang 新添加文件名编辑时的背景 leexingwang@2014/12/23 ADD START
		mFolderName.setBackgroundResource(R.drawable.rounded_edittext);
		mFolderName.getBackground().setAlpha(150);// 设置背景透明度为150 0----256
		// leexingwang 新添加文件名编辑时的背景 leexingwang@2014/12/23 ADD END
		mIsEditingName = true;
	}

	public void dismissEditingName() {
		mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
		// leexingwang leexingwang@2014/12/23 ADD START
		mFolderName.setBackgroundColor(Color.TRANSPARENT);
		// leexingwang leexingwang@2014/12/23 ADD END
		doneEditingFolderName(true);
	}

	public void doneEditingFolderName(boolean commit) {
		mFolderName.setHint(getResources().getString(R.string.folder_name));
		// leexingwang leexingwang@2014/12/23 ADD START
		mFolderName.setBackgroundColor(Color.TRANSPARENT);
		// leexingwang leexingwang@2014/12/23 ADD END
		// Convert to a string here to ensure that no other state associated
		// with the text field
		// gets saved.
		// leexingwang leexingwang@2014/12/23 ADD START
		String newTitle = mFolderName.getText().toString().isEmpty() ? getResources()
				.getString(R.string.folder_name) : mFolderName.getText()
				.toString();
		// leexingwang leexingwang@2014/12/23 ADD END
		mInfo.setTitle(newTitle);
		LauncherModel.updateItemInDatabase(mLauncher, mInfo);

		if (commit) {
			sendCustomAccessibilityEvent(
					AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
					String.format(
							getContext().getString(R.string.folder_renamed),
							newTitle));
		}
		// In order to clear the focus from the text field, we set the focus on
		// ourself. This
		// ensures that every time the field is clicked, focus is gained, giving
		// reliable behavior.
		requestFocus();

		Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
		mIsEditingName = false;
	}

	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
		if (actionId == EditorInfo.IME_ACTION_DONE) {
			dismissEditingName();
			return true;
		}
		return false;
	}

	public View getEditTextRegion() {
		return mFolderName;
	}

	public Drawable getDragDrawable() {
		return mIconDrawable;
	}

	/**
	 * We need to handle touch events to prevent them from falling through to
	 * the workspace below.
	 */
	@Override
	public boolean onTouchEvent(MotionEvent ev) {
		return true;
	}

	public void setDragController(DragController dragController) {
		mDragController = dragController;
	}

	void setFolderIcon(FolderIcon icon) {
		mFolderIcon = icon;
	}

	@Override
	public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
		// When the folder gets focus, we don't want to announce the list of
		// items.
		return true;
	}

	/**
	 * @return the FolderInfo object associated with this folder
	 */
	public FolderInfo getInfo() {
		return mInfo;
	}

	private class GridComparator implements Comparator<ShortcutInfo> {
		int mNumCols;

		public GridComparator(int numCols) {
			mNumCols = numCols;
		}

		@Override
		public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
			int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
			int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
			return (lhIndex - rhIndex);
		}
	}

	private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
		int maxX = 0;
		int count = items.size();
		for (int i = 0; i < count; i++) {
			ShortcutInfo item = items.get(i);
			if (item.cellX > maxX) {
				maxX = item.cellX;
			}
		}

		GridComparator gridComparator = new GridComparator(maxX + 1);
		Collections.sort(items, gridComparator);
		final int countX = mContent.getCountX();
		for (int i = 0; i < count; i++) {
			int x = i % countX;
			int y = i / countX;
			ShortcutInfo item = items.get(i);
			item.cellX = x;
			item.cellY = y;
		}
	}

	void bind(FolderInfo info) {
		mInfo = info;
		ArrayList<ShortcutInfo> children = info.contents;
		ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
		setupContentForNumItems(children.size());
		placeInReadingOrder(children);
		int count = 0;
		for (int i = 0; i < children.size(); i++) {
			ShortcutInfo child = (ShortcutInfo) children.get(i);
			if (!createAndAddShortcut(child)) {
				overflow.add(child);
			} else {
				count++;
			}
		}

		// We rearrange the items in case there are any empty gaps
		setupContentForNumItems(count);

		// If our folder has too many items we prune them from the list. This is
		// an issue
		// when upgrading from the old Folders implementation which could
		// contain an unlimited
		// number of items.
		for (ShortcutInfo item : overflow) {
			mInfo.remove(item);
			LauncherModel.deleteItemFromDatabase(mLauncher, item);
		}

		mItemsInvalidated = true;
		updateTextViewFocus();
		mInfo.addListener(this);
		// leexingwang leexingwang@2014/12/23 ADD START
		if (!getResources().getString(R.string.folder_name).contentEquals(
				mInfo.title))
		// leexingwang leexingwang@2014/12/23 ADD END
		{
			mFolderName.setText(mInfo.title);
		} else {
			mFolderName.setText("");
		}
		updateItemLocationsInDatabase();
	}

	/**
	 * Creates a new UserFolder, inflated from R.layout.user_folder.
	 * 
	 * @param context
	 *            The application's context.
	 * 
	 * @return A new UserFolder.
	 */
	static Folder fromXml(Context context) {
		return (Folder) LayoutInflater.from(context).inflate(
				R.layout.user_folder, null);
	}

	/**
	 * This method is intended to make the UserFolder to be visually identical
	 * in size and position to its associated FolderIcon. This allows for a
	 * seamless transition into the expanded state.
	 */
	private void positionAndSizeAsIcon() {
		if (!(getParent() instanceof DragLayer))
			return;
		// leexingwang 更改动画初始值 leexingwang@2014/12/22 UPD START
		// setScaleX(0.8f);
		// setScaleY(0.8f);
		setScaleX(1.0f);
		setScaleY(1.0f);
		setAlpha(1.0f);
		// leexingwang 更改动画初始值 leexingwang@2014/12/22 UPD END
		mState = STATE_SMALL;
	}

	public void animateOpen(FrameLayout frameLayoutFolderOpenAnimation) {
		frameLayout = frameLayoutFolderOpenAnimation;
		positionAndSizeAsIcon();
		if (!(getParent() instanceof DragLayer))
			return;
		centerAboutIcon();
		PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
		PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX",
				1.0f);
		PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY",
				1.0f);
		mFolderName.setAlpha(0.0f);
		final ObjectAnimator oa = mOpenCloseAnimator = LauncherAnimUtils
				.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
		oa.addListener(new AnimatorListenerAdapter() {

			@Override
			public void onAnimationStart(Animator animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String
								.format(getContext().getString(
										R.string.folder_opened),
										mContent.getCountX(),
										mContent.getCountY()));
				mState = STATE_ANIMATING;
			}

			@Override
			public void onAnimationEnd(Animator animation) {
				// leexingwang leexingwang@2014/12/29 ADD START
				mDragLayer = (DragLayer) mLauncher
						.findViewById(R.id.drag_layer);
				mDragLayer.addView(frameLayout);
				int[] location = new int[2];
				mContent.getLocationOnScreen(location); // 获取mcontent在整个屏幕内的绝对坐标
				points = new ArrayList<Point>();// 存储Folder中的icon的绝对桌标
				pointsLocationOnWindows = new ArrayList<Point>();// 存储folder中的icon的相对坐标
				int[] foldericonXY = new int[2];
				mFolderIcon.getLocationOnScreen(foldericonXY);// 得到foldericon的坐标
				Rect frame = new Rect();
				mLauncher.getWindow().getDecorView()
						.getWindowVisibleDisplayFrame(frame);// 获取状态栏的高度
				int statusBarHeight = frame.top;
				for (int i = 0; i < Math.min(mItemsInReadingOrder.size(),
						mMaxNumItems); i++) {
					Point point = new Point();
					int[] location1 = new int[2];
					mItemsInReadingOrder.get(i).getLocationOnScreen(location1);// 获取folder中icon的绝对坐标
					point.set(location1[0], location1[1] - statusBarHeight);// 减去状态栏的高度
					points.add(point);
					Point point2 = new Point();
					point2.set((int) mItemsInReadingOrder.get(i).getX(),
							(int) mItemsInReadingOrder.get(i).getY());
					pointsLocationOnWindows.add(point2);
				}
				mContent.removeAllViews();

				for (int i = 0; i < Math.min(mItemsInReadingOrder.size(),
						mMaxNumItems); i++) // 对文件夹中的每个icon做动画
				{
					mItemsInReadingOrder.get(i).setVisibility(View.VISIBLE);
					mItemsInReadingOrder.get(i).setX(foldericonXY[0]);
					mItemsInReadingOrder.get(i).setY(
							foldericonXY[1] - statusBarHeight);
					mItemsInReadingOrder.get(i).setScaleX(0.0f);
					mItemsInReadingOrder.get(i).setScaleY(0.0f);
					mItemsInReadingOrder.get(i).setAlpha(0.0f);
					PropertyValuesHolder translationX = PropertyValuesHolder
							.ofFloat("x", points.get(i).x);
					PropertyValuesHolder translationY = PropertyValuesHolder
							.ofFloat("y", points.get(i).y);
					PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(
							"alpha", 1);
					PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(
							"scaleX", 0.5f, 1.0f);
					PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(
							"scaleY", 0.5f, 1.0f);
					ObjectAnimator oa1 = mOpenCloseAnimator = LauncherAnimUtils
							.ofPropertyValuesHolder(
									mItemsInReadingOrder.get(i), alpha, scaleX,
									scaleY, translationX, translationY);
					oa1.setDuration(mLauncher.getResources().getInteger(
							R.integer.config_openfolderinnerAnimDuration));
					oa1.setupStartValues();
					oa1.setInterpolator(new AccelerateDecelerateInterpolator());
					// oa1.setInterpolator(new OvershootInterpolator(0.8f));
					if (i == 0) {
						oa1.addListener(new AnimatorListener() {

							@Override
							public void onAnimationStart(Animator animation) {
								// TODO Auto-generated method stub
								DragLayer.isOrNotOnClickDurtionOpenFolderAnimation = true;
							}

							@Override
							public void onAnimationRepeat(Animator animation) {
								// TODO Auto-generated method stub

							}

							@Override
							public void onAnimationEnd(Animator animation) {
								// TODO Auto-generated method stub
								mFolderName.setAlpha(1.0f);
							}

							@Override
							public void onAnimationCancel(Animator animation) {
								// TODO Auto-generated method stub
							}
						});

					}
					if (i == (Math.min(mItemsInReadingOrder.size(),
							mMaxNumItems) - 1)) {
						oa1.addListener(new AnimatorListener() {

							@Override
							public void onAnimationStart(Animator animation) {
								// TODO Auto-generated method stub
							}

							@Override
							public void onAnimationRepeat(Animator animation) {
								// TODO Auto-generated method stub

							}

							@Override
							public void onAnimationEnd(Animator animation) {
								// TODO Auto-generated method stub
								DragLayer.isOrNotOnClickDurtionOpenFolderAnimation = false;
								frameLayout.removeAllViews();
								mDragLayer.removeView(frameLayout);
								Log.i("mItemsInReadingOrdersize",
										"mItemsInReadingOrdersize:  "
												+ mItemsInReadingOrder.size());
								for (int i = 0; i < Math.min(
										mItemsInReadingOrder.size(),
										mMaxNumItems); i++) {
									Log.i("pointXY",
											"pointsLocationOnWindows.get(i).x:  "
													+ pointsLocationOnWindows
															.get(i).x);
									Log.i("pointXY",
											"pointsLocationOnWindows.get(i).y:  "
													+ pointsLocationOnWindows
															.get(i).y);
									Log.i("Value", "X:   " + i / mMaxCountX);
									Log.i("Value", "Y:   " + i % mMaxCountX);
									mItemsInReadingOrder.get(i).setX(
											pointsLocationOnWindows.get(i).x);
									mItemsInReadingOrder.get(i).setY(
											pointsLocationOnWindows.get(i).y);
									ShortcutInfo destInfo = (ShortcutInfo) mItemsInReadingOrder
											.get(i).getTag();
									mFolderIcon.addItem(destInfo);
								}
								// System.gc();
							}

							@Override
							public void onAnimationCancel(Animator animation) {
								// TODO Auto-generated method stub
							}
						});

					}
					oa1.setStartDelay(i
							* mLauncher
									.getResources()
									.getInteger(
											R.integer.config_openfolderinnerItemAnimDuration));// 每一个icon做动画的间隔时间
					setLayerType(LAYER_TYPE_HARDWARE, null);
					frameLayout.addView(mItemsInReadingOrder.get(i));
					oa1.start();
				}

				// leexingwang leexingwang@2014/12/29 ADD END
				mState = STATE_OPEN;
				setLayerType(LAYER_TYPE_NONE, null);
				// leexingwang 添加背景 leexingwang@2014/12/22 ADD START
				// DragLayer parent1 = (DragLayer) getParent();
				// if (parent1 != null) {
				// if (parent1.indexOfChild(mOpenBg) < 0
				// && mOpenBg.getParent() == null) {
				// parent1.addView(mOpenBg);
				// Folder.this.bringToFront();
				// Log.i(TAG,
				// "The Exception of bug276396 occurred and we made it work correct.");
				// }
				// } else {
				// Log.w(TAG, "onAnimationEnd: the parent is null!");
				// }
				// leexingwang 添加背景 leexingwang@2014/12/22 ADD END
				Cling cling = mLauncher.showFirstRunFoldersCling();
				if (cling != null) {
					cling.bringToFront();
				}
				setFocusOnFirstChild();
			}
		});
		// leexingwang 修改文件打开动画时间（加载整个文件夹在folder中icon做动画之前）
		// leexingwang@2015/01/06 UPD START
		// oa.setDuration(mExpandDuration);
		oa.setDuration(0);
		// leexingwang 修改文件打开动画时间（加载整个文件夹在folder中icon做动画之前）
		// leexingwang@2015/01/06 UPD END
		setLayerType(LAYER_TYPE_HARDWARE, null);
		buildLayer();
		post(new Runnable() {
			public void run() {
				// Check if the animator changed in the meantime
				if (oa != mOpenCloseAnimator)
					return;
				oa.start();
			}
		});
	}

	private void sendCustomAccessibilityEvent(int type, String text) {
		AccessibilityManager accessibilityManager = (AccessibilityManager) getContext()
				.getSystemService(Context.ACCESSIBILITY_SERVICE);
		if (accessibilityManager.isEnabled()) {
			AccessibilityEvent event = AccessibilityEvent.obtain(type);
			onInitializeAccessibilityEvent(event);
			event.getText().add(text);
			accessibilityManager.sendAccessibilityEvent(event);
		}
	}

	private void setFocusOnFirstChild() {
		View firstChild = mContent.getChildAt(0, 0);
		if (firstChild != null) {
			firstChild.requestFocus();
		}
	}

	public void animateClosed() {
		if (!(getParent() instanceof DragLayer))
			return;
		PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
		PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX",
				1.0f);
		PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY",
				1.0f);
		final ObjectAnimator oa = mOpenCloseAnimator = LauncherAnimUtils
				.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

		oa.addListener(new AnimatorListenerAdapter() {
			@Override
			public void onAnimationEnd(Animator animation) {
				onCloseComplete();
				setLayerType(LAYER_TYPE_NONE, null);
				mState = STATE_SMALL;
				// leexingwang 隐藏掉所有folder中的icon避免打开动画时闪烁问题
				// leexingwang@2015/01/06 ADD
				// START
				for (int i = 0; i < Math.min(mItemsInReadingOrder.size(),
						mMaxNumItems); i++) {
					mItemsInReadingOrder.get(i).setVisibility(View.INVISIBLE);
				}
				// leexingwang 隐藏掉所有folder中的icon避免打开动画时闪烁问题
				// leexingwang@2015/01/06 ADD END
			}

			@Override
			public void onAnimationStart(Animator animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
						getContext().getString(R.string.folder_closed));
				mState = STATE_ANIMATING;
			}
		});

		// leexingwang 关闭动画时间修改 leexingwang@2015/01/06 ADD START
		oa.setDuration(mLauncher.getResources().getInteger(
				R.integer.config_closefolderinnerAnimDuration));
		// leexingwang 关闭动画时间修改 leexingwang@2015/01/06 ADD END
		setLayerType(LAYER_TYPE_HARDWARE, null);
		buildLayer();
		post(new Runnable() {
			public void run() {
				// Check if the animator changed in the meantime
				if (oa != mOpenCloseAnimator)
					return;
				oa.start();
			}
		});
	}

	void notifyDataSetChanged() {
		// recreate all the children if the data set changes under us. We may
		// want to do this more
		// intelligently (ie just removing the views that should no longer
		// exist)
		mContent.removeAllViewsInLayout();
		bind(mInfo);
	}

	public boolean acceptDrop(DragObject d) {
		final ItemInfo item = (ItemInfo) d.dragInfo;
		final int itemType = item.itemType;
		return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) && !isFull());
	}

	protected boolean findAndSetEmptyCells(ShortcutInfo item) {
		int[] emptyCell = new int[2];
		if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
			item.cellX = emptyCell[0];
			item.cellY = emptyCell[1];
			return true;
		} else {
			return false;
		}
	}

	protected boolean createAndAddShortcut(ShortcutInfo item) {
		final TextView textView = (TextView) mInflater.inflate(
				R.layout.application, this, false);
		textView.setCompoundDrawablesWithIntrinsicBounds(null,
				new FastBitmapDrawable(item.getIcon(mIconCache)), null, null);
		textView.setText(item.title);
		textView.setTag(item);
		// leexingwang 设置文字颜色 leexingwang@2014/12/22 ADD START
		textView.setTextColor(getResources().getColor(
				R.color.folder_items_text_color));
		// leexingwang 设置文字颜色 leexingwang@2014/12/22 ADD END
		textView.setOnClickListener(this);
		textView.setOnLongClickListener(this);

		// We need to check here to verify that the given item's location isn't
		// already occupied
		// by another item.
		if (mContent.getChildAt(item.cellX, item.cellY) != null
				|| item.cellX < 0 || item.cellY < 0
				|| item.cellX >= mContent.getCountX()
				|| item.cellY >= mContent.getCountY()) {
			// This shouldn't happen, log it.
			Log.e(TAG, "Folder order not properly persisted during bind");
			if (!findAndSetEmptyCells(item)) {
				return false;
			}
		}

		CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX,
				item.cellY, item.spanX, item.spanY);
		boolean insert = false;
		textView.setOnKeyListener(new FolderKeyEventListener());
		mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int) item.id,
				lp, true);
		return true;
	}

	public void onDragEnter(DragObject d) {
		mPreviousTargetCell[0] = -1;
		mPreviousTargetCell[1] = -1;
		mOnExitAlarm.cancelAlarm();
	}

	OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			realTimeReorder(mEmptyCell, mTargetCell);
		}
	};

	boolean readingOrderGreaterThan(int[] v1, int[] v2) {
		if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
			return true;
		} else {
			return false;
		}
	}

	private void realTimeReorder(int[] empty, int[] target) {
		boolean wrap;
		int startX;
		int endX;
		int startY;
		int delay = 0;
		float delayAmount = 30;
		if (readingOrderGreaterThan(target, empty)) {
			wrap = empty[0] >= mContent.getCountX() - 1;
			startY = wrap ? empty[1] + 1 : empty[1];
			for (int y = startY; y <= target[1]; y++) {
				startX = y == empty[1] ? empty[0] + 1 : 0;
				endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
				for (int x = startX; x <= endX; x++) {
					View v = mContent.getChildAt(x, y);
					if (mContent.animateChildToPosition(v, empty[0], empty[1],
							REORDER_ANIMATION_DURATION, delay, true, true)) {
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		} else {
			wrap = empty[0] == 0;
			startY = wrap ? empty[1] - 1 : empty[1];
			for (int y = startY; y >= target[1]; y--) {
				startX = y == empty[1] ? empty[0] - 1
						: mContent.getCountX() - 1;
				endX = y > target[1] ? 0 : target[0];
				for (int x = startX; x >= endX; x--) {
					View v = mContent.getChildAt(x, y);
					if (mContent.animateChildToPosition(v, empty[0], empty[1],
							REORDER_ANIMATION_DURATION, delay, true, true)) {
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		}
	}

	public void onDragOver(DragObject d) {

		// leexingwang 设置蓝色框为显示 leexingwang@2014/12/22 ADD START

		if (mFolderBgIsOrNotShow) {
			mContent.setBackgroundResource(R.drawable.folder_edge_hint);
			mFolderBgIsOrNotShow = false;
		}
		// leexingwang leexingwang@2014/12/22 ADD END
		// leexingwang 判断是否拖到了蓝色边框的外部了 leexingwang@2014/12/22 ADD START
		if (d.y > mContent.getY() + mContent.getDesiredHeight()
				|| d.y < mContent.getY()) {
			completeDragExit();
		}
		// leexingwang 判断是否拖到了蓝色边框的外部了 leexingwang@2014/12/22 ADD END
		float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
				d.dragView, null);
		// Log.i("onDragOver", "getDragViewVisualCenter \n r[0]:" + r[0] + "\n"
		// + "r[2]:" + r[1]);
		// leexingwang 修改拖动过程中的目标值Y坐标 leexingwang@2014/12/22 ADD START
		r[1] = r[1]
				- ((mfolderUpperHalfPartPageIndicator.getHeight() + (int) getResources()
						.getDimension(R.dimen.folder_pagerview_margintop))
						+ mfolderUpperHalfPartPageIndicator.getHeight() + (int) getResources()
						.getDimension(
								R.dimen.folder_upper_half_part_page_indicator_margintop));
		// leexingwang 修改拖动过程中的目标值Y坐标 leexingwang@2014/12/22 ADD END
		mTargetCell = mContent.findNearestArea((int) r[0], (int) r[1], 1, 1,
				mTargetCell);
		// Log.i("mTargetCell", "mTargetCell \n mTargetCell0:  " +
		// mTargetCell[0]
		// + "\n" + "mTargetCell1:  " + mTargetCell[1]);
		if (mTargetCell[0] != mPreviousTargetCell[0]
				|| mTargetCell[1] != mPreviousTargetCell[1]) {
			mReorderAlarm.cancelAlarm();
			mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
			mReorderAlarm.setAlarm(150);
			mPreviousTargetCell[0] = mTargetCell[0];
			mPreviousTargetCell[1] = mTargetCell[1];
		}
	}

	// This is used to compute the visual center of the dragView. The idea is
	// that
	// the visual center represents the user's interpretation of where the item
	// is, and hence
	// is the appropriate point to use when determining drop location.
	private float[] getDragViewVisualCenter(int x, int y, int xOffset,
			int yOffset, DragView dragView, float[] recycle) {
		float res[];
		if (recycle == null) {
			res = new float[2];
		} else {
			res = recycle;
		}

		// These represent the visual top and left of drag view if a dragRect
		// was provided.
		// If a dragRect was not provided, then they correspond to the actual
		// view left and
		// top, as the dragRect is in that case taken to be the entire dragView.
		// R.dimen.dragViewOffsetY.
		int left = x - xOffset;
		int top = y - yOffset;

		// In order to find the visual center, we shift by half the dragRect
		res[0] = left + dragView.getDragRegion().width() / 2;
		res[1] = top + dragView.getDragRegion().height() / 2;
		return res;
	}

	OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			completeDragExit();
		}
	};

	public void completeDragExit() {
		mLauncher.closeFolder();
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;
		mRearrangeOnClose = true;
	}

	public void onDragExit(DragObject d) {
		// We only close the folder if this is a true drag exit, ie. not because
		// a drop
		// has occurred above the folder.
		// leexingwang 设置蓝色边框的透明度 leexingwang@2014/12/22 ADD START
		mContent.setBackgroundColor(Color.TRANSPARENT);
		mFolderBgIsOrNotShow = true;
		// leexingwang 设置蓝色边框的透明度 leexingwang@2014/12/22 ADD END
		if (!d.dragComplete) {
			mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
			mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
		}
		mReorderAlarm.cancelAlarm();
	}

	public void onDropCompleted(View target, DragObject d,
			boolean isFlingToDelete, boolean success) {
		if (success) {
			if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
				replaceFolderWithFinalItem();
			}
		} else {
			// The drag failed, we need to return the item to the folder
			mFolderIcon.onDrop(d);

			// We're going to trigger a "closeFolder" which may occur before
			// this item has
			// been added back to the folder -- this could cause the folder to
			// be deleted
			if (mOnExitAlarm.alarmPending()) {
				mSuppressFolderDeletion = true;
			}
		}

		if (target != this) {
			if (mOnExitAlarm.alarmPending()) {
				mOnExitAlarm.cancelAlarm();
				completeDragExit();
			}
		}
		mDeleteFolderOnDropCompleted = false;
		mDragInProgress = false;
		mItemAddedBackToSelfViaIcon = false;
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;

		// Reordering may have occured, and we need to save the new item
		// locations. We do this once
		// at the end to prevent unnecessary database operations.
		updateItemLocationsInDatabase();
	}

	@Override
	public boolean supportsFlingToDelete() {
		return true;
	}

	public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
		// Do nothing
	}

	@Override
	public void onFlingToDeleteCompleted() {
		// Do nothing
	}

	private void updateItemLocationsInDatabase() {
		ArrayList<View> list = getItemsInReadingOrder();
		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			ItemInfo info = (ItemInfo) v.getTag();
			LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
					info.cellX, info.cellY);
		}
	}

	public void notifyDrop() {
		if (mDragInProgress) {
			mItemAddedBackToSelfViaIcon = true;
		}
	}

	public boolean isDropEnabled() {
		return true;
	}

	public DropTarget getDropTargetDelegate(DragObject d) {
		return null;
	}

	private void setupContentDimensions(int count) {
		ArrayList<View> list = getItemsInReadingOrder();

		int countX = mContent.getCountX();
		int countY = mContent.getCountY();
		boolean done = false;

		// leexingwang 修改文件夹内部的行列变化规律 leexingwang@2014/12/19 UPD START
		// while (!done) {
		// int oldCountX = countX;
		// int oldCountY = countY;
		// if (countX * countY < count) {
		// // Current grid is too small, expand it
		// if ((countX <= countY || countY == mMaxCountY)
		// && countX < mMaxCountX) {
		// countX++;
		// } else if (countY < mMaxCountY) {
		// countY++;
		// }
		// if (countY == 0)
		// countY++;
		// } else if ((countY - 1) * countX >= count && countY >= countX) {
		// countY = Math.max(0, countY - 1);
		// } else if ((countX - 1) * countY >= count) {
		// countX = Math.max(0, countX - 1);
		// }
		// done = countX == oldCountX && countY == oldCountY;
		// }
		while (!done) {
			int oldCountY = countY;
			if (mMaxCountX * countY < count) {
				if (countY < mMaxCountY) {
					countY++;
				}
			} else if ((countY - 1) * mMaxCountX >= count) {
				countY = Math.max(0, countY - 1);
			}
			done = (countY == oldCountY);
		}
		mContent.setGridSize(mMaxCountX, countY);
		// leexingwang 修改文件夹内部的行列变化规律 leexingwang@2014/12/19 UPD END
		arrangeChildren(list);
	}

	public boolean isFull() {
		return getItemCount() >= mMaxNumItems;
	}

	private void centerAboutIcon() {
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
		int width = getPaddingLeft() + getPaddingRight()
				+ mContent.getDesiredWidth();
		// leexingwang 修改文件夹的高 leexingwang@2014/12/22 UPD START
		// int height = getPaddingTop() + getPaddingBottom()
		int height = getPaddingTop()
				+ getPaddingBottom()
				+ mfolderUpperHalfPartPageIndicator.getHeight()
				+ (int) getResources()
						.getDimension(
								R.dimen.folder_upper_half_part_page_indicator_margintop)
				+ (int) getResources().getDimension(
						R.dimen.folder_pagerview_margintop)
				// + (int) getResources().getDimension(
				// R.dimen.folder_add_button_margintop)
				// + mFolderAddButton.getHeight()
				+ mContent.getDesiredHeight() + mFolderNameHeight;
		// leexingwang 修改文件夹的高 leexingwang@2014/12/22 UPD END
		DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
		float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon,
				mTempRect);
		int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
		int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
		int centeredLeft = centerX - width / 2;
		int centeredTop = centerY - height / 2;
		int currentPage = mLauncher.getWorkspace().getCurrentPage();
		// In case the workspace is scrolling, we need to use the final scroll
		// to compute
		// the folders bounds.
		mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
		// We first fetch the currently visible CellLayoutChildren
		CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace()
				.getChildAt(currentPage);
		ShortcutAndWidgetContainer boundingLayout = currentLayout
				.getShortcutsAndWidgets();
		Rect bounds = new Rect();
		parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
		// We reset the workspaces scroll
		mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);

		// We need to bound the folder to the currently visible
		// CellLayoutChildren
		int left = Math.min(Math.max(bounds.left, centeredLeft), bounds.left
				+ bounds.width() - width);
		int top = Math.min(Math.max(bounds.top, centeredTop), bounds.top
				+ bounds.height() - height);
		// If the folder doesn't fit within the bounds, center it about the
		// desired bounds
		if (width >= bounds.width()) {
			left = bounds.left + (bounds.width() - width) / 2;
		}
		if (height >= bounds.height()) {
			top = bounds.top + (bounds.height() - height) / 2;
		}
		int folderPivotX = width / 2 + (centeredLeft - left);
		int folderPivotY = height / 2 + (centeredTop - top);
		setPivotX(folderPivotX);
		setPivotY(folderPivotY);
		mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() * (1.0f * folderPivotX / width));
		mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() * (1.0f * folderPivotY / height));
		lp.width = width;
		lp.height = height;
		// lp.x = left;
		// lp.y = top;
	}

	public float getPivotXForIconAnimation() {
		return mFolderIconPivotX;
	}

	public float getPivotYForIconAnimation() {
		return mFolderIconPivotY;
	}

	private void setupContentForNumItems(int count) {
		setupContentDimensions(count);
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
		if (lp == null) {
			lp = new DragLayer.LayoutParams(0, 0);
			lp.customPosition = true;
			setLayoutParams(lp);
		}
		centerAboutIcon();
	}

	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		// leexingwang leexingwang@2014/12/22 UPD START
		// // int width = getPaddingLeft() + getPaddingRight()
		// // + mContent.getDesiredWidth();
		// // int height = getPaddingTop() + getPaddingBottom()
		// // + mContent.getDesiredHeight() + mFolderNameHeight;
		// //
		// // int contentWidthSpec = MeasureSpec.makeMeasureSpec(
		// // mContent.getDesiredWidth(), MeasureSpec.EXACTLY);
		// // int contentHeightSpec = MeasureSpec.makeMeasureSpec(
		// // mContent.getDesiredHeight(), MeasureSpec.EXACTLY);
		// // mContent.measure(contentWidthSpec, contentHeightSpec);
		// //
		// // mFolderName.measure(contentWidthSpec, MeasureSpec.makeMeasureSpec(
		// // mFolderNameHeight, MeasureSpec.EXACTLY));
		// // setMeasuredDimension(width, height);
		// // int contentWidthSpec = MeasureSpec.makeMeasureSpec(
		// // mFolderAddButton.getWidth(), MeasureSpec.AT_MOST);
		// // int contentHeightSpec = MeasureSpec.makeMeasureSpec(
		// // mFolderAddButton.getHeight(), MeasureSpec.EXACTLY);
		// // mContent.measure(contentWidthSpec, contentHeightSpec);
		// // mFolderAddButton.measure(widthMeasureSpec, heightMeasureSpec);
		// leexingwang leexingwang@2014/12/22 UPD END
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
	}

	private void arrangeChildren(ArrayList<View> list) {
		int[] vacant = new int[2];
		if (list == null) {
			list = getItemsInReadingOrder();
		}
		mContent.removeAllViews();

		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			mContent.getVacantCell(vacant, 1, 1);
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v
					.getLayoutParams();
			lp.cellX = vacant[0];
			lp.cellY = vacant[1];
			ItemInfo info = (ItemInfo) v.getTag();
			if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
				info.cellX = vacant[0];
				info.cellY = vacant[1];
				LauncherModel.addOrMoveItemInDatabase(mLauncher, info,
						mInfo.id, 0, info.cellX, info.cellY);
			}
			boolean insert = false;
			mContent.addViewToCellLayout(v, insert ? 0 : -1, (int) info.id, lp,
					true);
		}
		mItemsInvalidated = true;
	}

	public int getItemCount() {
		return mContent.getShortcutsAndWidgets().getChildCount();
	}

	public View getItemAt(int index) {
		return mContent.getShortcutsAndWidgets().getChildAt(index);
	}

	private void onCloseComplete() {
		DragLayer parent = (DragLayer) getParent();
		if (parent != null) {
			parent.removeView(this);
			// leexingwang 移除文件夹的背景 leexingwang@2014/12/22 ADD START
			parent.removeView(mOpenBg);
			// leexingwang 移除文件夹的背景 leexingwang@2014/12/22 ADD END
		}
		mDragController.removeDropTarget((DropTarget) this);
		clearFocus();
		mFolderIcon.requestFocus();

		if (mRearrangeOnClose) {
			setupContentForNumItems(getItemCount());
			mRearrangeOnClose = false;
		}
		if (getItemCount() <= 1) {
			if (!mDragInProgress && !mSuppressFolderDeletion) {
				replaceFolderWithFinalItem();
			} else if (mDragInProgress) {
				mDeleteFolderOnDropCompleted = true;
			}
		}
		mSuppressFolderDeletion = false;

	}

	private void replaceFolderWithFinalItem() {
		// Add the last remaining child to the workspace in place of the folder
		Runnable onCompleteRunnable = new Runnable() {
			@Override
			public void run() {
				CellLayout cellLayout = mLauncher.getCellLayout(
						mInfo.container, mInfo.screen);

				View child = null;
				// Move the item from the folder to the workspace, in the
				// position of the folder
				if (getItemCount() == 1) {
					ShortcutInfo finalItem = mInfo.contents.get(0);
					child = mLauncher.createShortcut(R.layout.application,
							cellLayout, finalItem);
					LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem,
							mInfo.container, mInfo.screen, mInfo.cellX,
							mInfo.cellY);
				}
				if (getItemCount() <= 1) {
					// Remove the folder
					LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
					cellLayout.removeView(mFolderIcon);
					if (mFolderIcon instanceof DropTarget) {
						mDragController
								.removeDropTarget((DropTarget) mFolderIcon);
					}
					mLauncher.removeFolder(mInfo);
				}
				// We add the child after removing the folder to prevent both
				// from existing at
				// the same time in the CellLayout.
				if (child != null) {
					mLauncher.getWorkspace().addInScreen(child,
							mInfo.container, mInfo.screen, mInfo.cellX,
							mInfo.cellY, mInfo.spanX, mInfo.spanY);
				}
			}
		};
		View finalChild = getItemAt(0);
		if (finalChild != null) {
			mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
		}
		mDestroyed = true;
	}

	public boolean isDestroyed() {
		return mDestroyed;
	}

	// This method keeps track of the last item in the folder for the purposes
	// of keyboard focus
	private void updateTextViewFocus() {
		View lastChild = getItemAt(getItemCount() - 1);
		getItemAt(getItemCount() - 1);
		if (lastChild != null) {
			mFolderName.setNextFocusDownId(lastChild.getId());
			mFolderName.setNextFocusRightId(lastChild.getId());
			mFolderName.setNextFocusLeftId(lastChild.getId());
			mFolderName.setNextFocusUpId(lastChild.getId());
		}
	}

	public void onDrop(DragObject d) {
		ShortcutInfo item;
		if (d.dragInfo instanceof ApplicationInfo) {
			// Came from all apps -- make a copy
			item = ((ApplicationInfo) d.dragInfo).makeShortcut();
			item.spanX = 1;
			item.spanY = 1;
		} else {
			item = (ShortcutInfo) d.dragInfo;
		}
		// Dragged from self onto self, currently this is the only path
		// possible, however
		// we keep this as a distinct code path.
		if (item == mCurrentDragInfo) {
			ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView
					.getLayoutParams();
			si.cellX = lp.cellX = mEmptyCell[0];
			si.cellX = lp.cellY = mEmptyCell[1];
			mContent.addViewToCellLayout(mCurrentDragView, -1, (int) item.id,
					lp, true);
			if (d.dragView.hasDrawn()) {
				mLauncher.getDragLayer().animateViewIntoPosition(d.dragView,
						mCurrentDragView);
			} else {
				d.deferDragViewCleanupPostAnimation = false;
				mCurrentDragView.setVisibility(VISIBLE);
			}
			mItemsInvalidated = true;
			setupContentDimensions(getItemCount());
			mSuppressOnAdd = true;
		}
		mInfo.add(item);
	}

	public void onAdd(ShortcutInfo item) {
		mItemsInvalidated = true;
		// If the item was dropped onto this open folder, we have done the work
		// associated
		// with adding the item to the folder, as indicated by mSuppressOnAdd
		// being set
		if (mSuppressOnAdd)
			return;
		if (!findAndSetEmptyCells(item)) {
			// The current layout is full, can we expand it?
			setupContentForNumItems(getItemCount() + 1);
			findAndSetEmptyCells(item);
		}
		createAndAddShortcut(item);
		LauncherModel.addOrMoveItemInDatabase(mLauncher, item, mInfo.id, 0,
				item.cellX, item.cellY);
	}

	public void onRemove(ShortcutInfo item) {
		mItemsInvalidated = true;
		// If this item is being dragged from this open folder, we have already
		// handled
		// the work associated with removing the item, so we don't have to do
		// anything here.
		if (item == mCurrentDragInfo)
			return;
		View v = getViewForInfo(item);
		mContent.removeView(v);
		if (mState == STATE_ANIMATING) {
			mRearrangeOnClose = true;
		} else {
			setupContentForNumItems(getItemCount());
		}
		if (getItemCount() <= 1) {
			replaceFolderWithFinalItem();
		}
	}

	private View getViewForInfo(ShortcutInfo item) {
		for (int j = 0; j < mContent.getCountY(); j++) {
			for (int i = 0; i < mContent.getCountX(); i++) {
				View v = mContent.getChildAt(i, j);
				if (v.getTag() == item) {
					return v;
				}
			}
		}
		return null;
	}

	public void onItemsChanged() {
		updateTextViewFocus();
	}

	public void onTitleChanged(CharSequence title) {
	}

	public ArrayList<View> getItemsInReadingOrder() {
		return getItemsInReadingOrder(true);
	}

	public ArrayList<View> getItemsInReadingOrder(boolean includeCurrentDragItem) {
		if (mItemsInvalidated) {
			mItemsInReadingOrder.clear();
			for (int j = 0; j < mContent.getCountY(); j++) {
				for (int i = 0; i < mContent.getCountX(); i++) {
					View v = mContent.getChildAt(i, j);
					if (v != null) {
						ShortcutInfo info = (ShortcutInfo) v.getTag();
						if (info != mCurrentDragInfo || includeCurrentDragItem) {
							mItemsInReadingOrder.add(v);
						}
					}
				}
			}
			mItemsInvalidated = false;
		}
		return mItemsInReadingOrder;
	}

	public void getLocationInDragLayer(int[] loc) {
		mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
	}

	public void onFocusChange(View v, boolean hasFocus) {
		if (v == mFolderName && hasFocus) {
			startEditingFolderName();
		}
	}

	// leexingwang 添加设置背景的方法 leexingwang@2014/12/22 ADD START
	public void setOpenBg(View mFolderBg) {
		// TODO Auto-generated method stub
		mOpenBg = mFolderBg;
	}

	// leexingwang 添加设置背景的方法 leexingwang@2014/12/22 ADD END

}
